MODULE mo_window_cal

! Module for optimization of the HBV model by Monte Carlo simulation. It will produce several files in the folders "Cal" and "Val":
! Pareto_Q.txt  		: simulated river discharge for all pareto optimal solutions
! Swe.txt			: snow water equivalent for all pareto optimal solutions
! rmoist.txt			: relative moisture content for all pareto optimal solutions.
! rain.txt			: rain for all pareto optimal solutions  
! snow.txt			: snow  for all pareto optimal solutions
! melt.txt			: melt water equivalent for all pareto optimal solutions
! q0.txt			: surface runoff for all pareto optimal solutions
! q1.txt			: fast runoff for all pareto optimal solutions
! q2.txt			: slow runoff for all pareto optimal solutions
! eta.txt			: evaporation for all pareto optimal solutions
! suz.txt			: upper zone storage for all pareto optimal solutions
! slz.txt			: lower zone storage for all pareto optimal solutions
! rslz.txt			: relative lower zone storage for all pareto optimal solutions
! Objectives.txt		: objective function values for all pareto optimal solutions
! Pareto_parameters.txt		: parameters for all pareto optimal solutions
! Feasible_objectives.txt	: objective function values all feasible solutions (0>)

!Written by: R.C. Nijzink June 2014
!References: 
!Adjustments: 



IMPLICIT NONE

CONTAINS

	subroutine window_cal(par_ini, par_max,par_min,incon, prec_data,temp_data,etp_data,&
                             dem, cellsize,Qobs_data, dates_data, optim, sumax_data)
		
USE mo_model
USE mo_readdata
USE mo_objectives
USE mo_eval_signatures
USE mo_init_random_seed

	real*8,dimension(13), intent(in)		:: par_ini	! maximum parameter values
	real*8,dimension(13), intent(in)		:: par_max	! maximum parameter values
	real*8,dimension(13), intent(in)		:: par_min	! minimum parameter values
	real*8,dimension(4), intent(in)		        :: incon	! initial conditions states
	real*8,dimension(:), allocatable, intent(in)	:: prec_data 	! precipitation data
	real*8,dimension(:), allocatable, intent(in)	:: temp_data 	! temperature data
	real*8,dimension(:), allocatable, intent(in)	:: etp_data	! evaporation data
        real*8, dimension(:,:), allocatable, intent(in) :: dem
        real*8,intent(in)                               :: cellsize
	real*8,dimension(:), allocatable, intent(in)	:: Qobs_data	! observed discharge
	character*10,dimension(:),allocatable,intent(in):: dates_data	! observed discharge
	logical,dimension(10), intent(in)		:: optim	! minimum parameter values
	real*8,dimension(:), allocatable, intent(in)	:: sumax_data 	! sumax data


        real*8,dimension(13) 				:: r		! random number array
	real*8,dimension(13)             		:: par_val	! minimum parameter values
	real*8,dimension(13)             		:: paramset	! set of parameters
	real*8,allocatable, dimension(:)		:: q		! modelled discharge
	real*8,allocatable, dimension(:)		:: qval		! validation discharge
	real*8, dimension(26)            	        :: EC    	! evalutation criteria
	real*8, dimension(26) 	                        :: ECval    	! evalutation criteria
	real*8						:: NSE		! Nash-Sutcliffe efficienct
	real*8						:: LNSE		! log NSE
	real*8						:: VE		! Volume error
	real*8						:: FDC_NSE	! Nash of flow duration curve
	real*8						:: NSE_val	! NSE for validation	
	real*8						:: LNSE_val	! log NSE for validation
	real*8						:: VE_val	! Volume error validation
	real*8						:: FDC_NSE_val	! validation Nash FDC
	integer						:: length	! length of period
	integer						:: val_length	! length of validation period
	real*8, allocatable, dimension(:,:)	        :: output	! output matrix
	real*8, allocatable, dimension(:,:)	        :: output_ini	! output matrix
	real*8, allocatable, dimension(:,:)	        :: output_val	! output matrix validation
	integer						:: nn 		! counter
	integer, allocatable, dimension(:)		:: seed		! initial random seed
	integer						:: t		! counter
	integer, allocatable, dimension(:)		:: count_feasibles !number of feasible sets
	integer						:: count_solutions !number of final solutions
	integer						:: j		! counter
	integer						:: i		! counter
	integer						:: k		! counter
	integer						:: m		! counter
	integer						:: jj		! counter
	integer						:: ii		! counter
        integer                                         :: iWindow      ! window counter
	real*8						:: bound1	! pareto_bound
	real*8						:: bound2	! pareto_bound
	real*8						:: bound3	! pareto_bound
	real*8						:: bound4	! pareto_bound
        integer                                         :: end_ind
        integer                                         :: endyear
        integer                                         :: extra
	real*8,dimension(:), allocatable        	:: prec_in 	! precipitation data
	real*8,dimension(:), allocatable        	:: etp_in 	! precipitation data
	real*8,dimension(:), allocatable        	:: temp_in 	! precipitation data
	real*8, dimension(:,:), allocatable		:: par_mat	! matrix with parameters
	real*8, dimension(:,:), allocatable		:: Su_mat	! matrix with modelled Q
	real*8, dimension(:,:), allocatable		:: Ea_mat	! matrix with modelled Q
	real*8, dimension(:,:), allocatable		:: Ei_mat	! matrix with modelled Q
	real*8, dimension(:,:), allocatable		:: Snow_mat	! matrix with modelled Q
	real*8, dimension(:,:), allocatable		:: Ss_mat	! matrix with modelled Q
	real*8, dimension(:,:), allocatable		:: Sf_mat	! matrix with modelled Q
	real*8, dimension(:,:), allocatable		:: Q_mat	! matrix with modelled Q
	real*8, dimension(:,:), allocatable		:: qval_mat	! matrix with validated Q
	real*8, dimension(:,:), allocatable		:: outputval_mat! output validation		
	real*8, dimension(:,:), allocatable		:: obj_mat	! matrix with objective functions
	real*8, dimension(:,:), allocatable		:: pareto_obj	! matrix with pareto objective function values
	real*8, dimension(:,:), allocatable		:: pareto_par	! matrix with pareto objective function values
	real*8, dimension(:,:), allocatable		:: pareto_su	! matrix with pareto objective function values
	real*8, dimension(:,:), allocatable		:: pareto_ea	! matrix with pareto objective function values
	real*8, dimension(:,:), allocatable		:: pareto_ei	! matrix with pareto objective function values
	real*8, dimension(:,:), allocatable		:: pareto_q	! matrix with pareto objective function values
        real*8, dimension(:,:), allocatable		:: pareto_snow	! matrix with pareto objective function values
real*8, dimension(:,:), allocatable		:: pareto_ss	! matrix with pareto objective function values
real*8, dimension(:,:), allocatable		:: pareto_sf	! matrix with pareto objective function values
        integer                                         :: start_ind
        integer                                         :: startyear
        character(10)                                    :: temp_date
        character(10)                                    :: temp_date2
        integer                                         :: fileunit	
	real*8, dimension(:,:), allocatable		:: final_obj	! matrix with final objective function values
	real*8, dimension(:,:), allocatable		:: final_par	! matrix with final parameters
	real*8, dimension(:,:,:), allocatable		:: final_out    ! matrix with final
	real*8, dimension(:,:), allocatable		:: final_states ! matrix with final states
	logical, dimension(:), allocatable		:: temp, temp1	! temperoray arrays
	character(256)                        		:: formData	! format of data
	character(256)                        		:: formDataObj	! format of data objectives
	character(256)                        		:: formDataPar	! format of data parameters
	character(256)                        		:: formHeader	! format of data headers
	character(256)                        		:: formHeaderPar! format of headers
	real*8, dimension(:,:,:), allocatable		:: incon_mat	! matrix with parameters
	real*8,dimension(4)        		        :: incon_val	! initial conditions states
        integer                                         :: nWindow
	integer						:: pareto_length! number of pareto solutions
	integer						:: uFinalStates	! file unit Q validation
	integer						:: uObj		! file unit all objectives
	integer						:: uParam	! file unit parameters
	integer						:: uQ 		! file unit Q
	integer						:: uSu 		! file unit Su
	integer						:: uEa 		! file unit Ea
	integer						:: uEi 		! file unit Q
	integer						:: uSnow	! file unit Q
	integer						:: uSs	! file unit Q
	integer						:: uSf	! file unit Q
        real*8                                          :: fIt
        character(10)                                   :: window_string




!initialize




temp_date=dates_data(ic_start)
temp_date2=dates_data(ic_end)

read( temp_date(1:4) ,'(I4)') startyear
read(temp_date2(1:4) ,'(I4)') endyear 


nWindow = ceiling(real(endyear-startyear,8)/real(window))

uParam=14
uQ=uParam+1+nWindow
uObj=uQ+1+nWindow
uSu=uObj+1+nWindow
uEa=uSu+1+nWindow
uEi=uEa+1+nWindow
uSnow=uEi+1+nWindow
uSs=uSnow+1+nWindow
uSf=uSs+1+nWindow

length=size(prec_data( iw_start:ic_end ))
allocate( q( length) )
allocate( count_feasibles( nWindow  ) )
allocate(prec_in (length+(iw_end-iw_start) ))
allocate(etp_in (length+(iw_end-iw_start) ))
allocate(temp_in (length+(iw_end-iw_start) ))

count_feasibles = 0
fIt = 0.1
paramset=par_ini

call init_random_seed()



window = window*365
print *, 'Windows:', nWindow

!start monte carlo runs

do iWindow =1, nWindow
           write(window_string,'(I0)') iWindow
           open(uParam+iWindow, file= trim(adjustl("temp/Param_temp"))// &
                 trim(adjustl(window_string)), status='unknown', action='write')
           open(uQ+iWindow, file= trim(adjustl("temp/Q_temp")) //&
                 trim(adjustl(window_string)), status='unknown', action='write')
           open(uObj+iWindow, file= trim(adjustl("temp/Obj_temp"))// &
                 trim(adjustl(window_string)), status='unknown', action='write')
           open(uSu+iWindow, file= trim(adjustl("temp/Su_temp"))// &
                 trim(adjustl(window_string)), status='unknown', action='write')
!           open(uEa+iWindow, file= trim(adjustl("temp/Ea_temp"))// &
!                 trim(adjustl(window_string)), status='unknown', action='write')
!           open(uEi+iWindow, file= trim(adjustl("temp/Ei_temp"))// &
!                 trim(adjustl(window_string)), status='unknown', action='write')
!           open(uSnow+iWindow, file= trim(adjustl("temp/Snow_temp"))// &
!                 trim(adjustl(window_string)), status='unknown', action='write')
!           open(uSs+iWindow, file= trim(adjustl("temp/Ss_temp"))// &
!                 trim(adjustl(window_string)), status='unknown', action='write')
!           open(uSf+iWindow, file= trim(adjustl("temp/Sf_temp"))// &
!                 trim(adjustl(window_string)), status='unknown', action='write')
end do



 do nn=1, Iterations

	call random_number(r)

        forall(ii=1:size(paramset,1),optim(ii) .eqv. .TRUE.) paramset(ii)=r(ii)*(par_max(ii)-par_min(ii))+par_min(ii) 


        !run the whole model
        !add artificial warmup period
        if(iw_start .eq. ic_start) then
           prec_in = (/ prec_data( iw_start:iw_end ), prec_data( iw_start:ic_end ) /)
           etp_in  = (/ etp_data( iw_start:iw_end ) , etp_data( iw_start:ic_end ) /)
           temp_in = (/ temp_data( iw_start:iw_end ), temp_data( iw_start:ic_end ) /)
           ic_end  =ic_end+iw_end 


        else
           prec_in =  prec_data( iw_start:ic_end )
           etp_in  =  etp_data( iw_start:ic_end ) 
           temp_in =  temp_data( iw_start:ic_end ) 

!print *, prec_in(110)
!print *, etp_in(110)
!stop
        end if



!	call model(paramset,output_ini(8:11,iw_end), prec_data( iw_start:ic_end ) &
!	,temp_data(iw_start:ic_end),etp_data(iw_start:ic_end), dem, cellsize, output)

        if(dyn_mode .eqv. .TRUE.) then 
           call model(paramset,incon, prec_in, temp_in, etp_in, dem, cellsize, output, sumax_data)
        else
           call model(paramset,incon, prec_in, temp_in, etp_in, dem, cellsize, output)
        end if

	q=output(1,:)

        extra=0
	!determine objectives for each window period
        iWindow = 1
        do jj= ic_start-1, ic_end-window, window

          start_ind = jj+1+extra
          end_ind   = jj+window+extra

          !check for uneven years
          temp_date=dates_data(start_ind)
          temp_date2=dates_data(end_ind+1)
          if(temp_date(6:10) .ne. temp_date2(6:10)) then
             end_ind=end_ind+1
             extra=extra+1
          end if

          if( (end_ind) .gt. ic_end) then 
            end_ind = ic_end
          end if



	   call NashEfficiency(Qobs_data(start_ind:end_ind),q(start_ind:end_ind), NSE)
	   call LogNashEfficiency(Qobs_data(start_ind:end_ind),q(start_ind:end_ind), LNSE)
	   call VolumeError(Qobs_data(start_ind:end_ind),q(start_ind:end_ind), VE)
	   call FDCNashEfficiency(Qobs_data(start_ind:end_ind),q(start_ind:end_ind), FDC_NSE)

	   !keep parameter set when all objectives are bigger than 0, with maximum size of 5000

!	   if( (NSE .gt. zero_dp) .and. (LNSE .gt. zero_dp) .and. (VE .gt. zero_dp) .and. (FDC_NSE .gt. zero_dp) ) then
	   count_feasibles(iWindow) = count_feasibles(iWindow) + 1

!	   par_mat(:,count_feasibles(iWindow),iWindow)     = paramset		!every column is one run
!	   Q_mat(:, count_feasibles(iWindow),iWindow) = output(1,start_ind:end_ind)
!	   obj_mat(:,count_feasibles(iWindow), iWindow)= (/NSE, LNSE, VE, FDC_NSE/)

           write(uParam+iWindow,*),  paramset         
           write(uQ+iWindow,*),  output(1,start_ind:end_ind)
           write(uObj+iWindow,*) (/NSE, LNSE, VE, FDC_NSE/)
           write(uSu+iWindow,*) output(9,start_ind:end_ind)
!           write(uEa+iWindow,*) output(5,start_ind:end_ind)
!           write(uEi+iWindow,*) output(6,start_ind:end_ind)
!           write(uSnow+iWindow,*) output(12,start_ind:end_ind)
!           write(uSs+iWindow,*) output(11,start_ind:end_ind)
!           write(uSf+iWindow,*) output(10,start_ind:end_ind)
!	   end if
        iWindow = iWindow+1 



        end do

        if(nn .eq. int(fIt*Iterations)) then
        print *, "Iterations finished: ", nn
        print *, "Feasible solutions : ", count_feasibles 
        print *, ""
        fIt = fIt + 0.1
      end if

 end do

do iWindow =1, nWindow
           close(uParam+iWindow)
           close(uQ+iWindow)
           close(uObj+iWindow)
           close(uSu+iWindow)
!           close(uEa+iWindow)
!           close(uEi+iWindow)
!           close(uSnow+iWindow)
!           close(uSs+iWindow)
!           close(uSf+iWindow)
end do
 


print *, "Feasible parameter sets:"
print *, count_feasibles
print *, ''

!now create pareto front for each window


do iWindow = 1, nWindow

allocate( Q_mat( window, int(Iterations) ) )
allocate( Su_mat( window, int(Iterations) ) )
!allocate( Ea_mat( window, int(Iterations) ) )
!allocate( Ei_mat( window, int(Iterations) ) )
!allocate( Snow_mat( window, int(Iterations) ) )
!allocate( Ss_mat( window, int(Iterations) ) )
!allocate( Sf_mat( window, int(Iterations) ) )
allocate( par_mat(12, int(Iterations) ) )
allocate( obj_mat(4, int(Iterations) ) )

   write(window_string,'(I0)') iWindow

   open(uParam+iWindow, file=trim(adjustl("temp/Param_temp"))// &
                 trim(adjustl(window_string)), status='unknown', action='read')
   open(uQ+iWindow, file=trim(adjustl("temp/Q_temp")) //&
                 trim(adjustl(window_string)), status='unknown', action='read')
   open(uObj+iWindow, file=trim(adjustl("temp/Obj_temp"))// &
                 trim(adjustl(window_string)), status='unknown', action='read')
   open(uSu+iWindow, file=trim(adjustl("temp/Su_temp"))// &
                 trim(adjustl(window_string)), status='unknown', action='read')
!   open(uEa+iWindow, file=trim(adjustl("temp/Ea_temp"))// &
!                  trim(adjustl(window_string)), status='unknown', action='read')
!   open(uEi+iWindow, file=trim(adjustl("temp/Ei_temp"))// &
!                 trim(adjustl(window_string)), status='unknown', action='read')
!   open(uSnow+iWindow, file=trim(adjustl("temp/Snow_temp"))// &
!                 trim(adjustl(window_string)), status='unknown', action='read')
!   open(uSs+iWindow, file=trim(adjustl("temp/Ss_temp"))// &
!                 trim(adjustl(window_string)), status='unknown', action='read')
!   open(uSf+iWindow, file=trim(adjustl("temp/Sf_temp"))// &
!                 trim(adjustl(window_string)), status='unknown', action='read')

do i=1, count_feasibles(iWindow)
   read(uObj+iWindow,*) obj_mat(:,i)
   read(uParam+iWindow,*) par_mat(:,i)
if(iw_end+window*(iWindow) .lt. ic_end) then
   read(uQ+iWindow,*) Q_mat(1:window,i) !qmat te lang, loopt dus door met vullen 
   read(uSu+iWindow,*) Su_mat(1:window,i) !qmat te lang, loopt dus door met vullen 
  ! read(uEa+iWindow,*) Ea_mat(1:window,i) !qmat te lang, loopt dus door met vullen 
  ! read(uEi+iWindow,*) Ei_mat(1:window,i) !qmat te lang, loopt dus door met vullen 
  ! read(uSnow+iWindow,*) Snow_mat(1:window,i) !qmat te lang, loopt dus door met vullen 
  ! read(uSs+iWindow,*) Ss_mat(1:window,i) !qmat te lang, loopt dus door met vullen 
  ! read(uSf+iWindow,*) Sf_mat(1:window,i) !qmat te lang, loopt dus door met vullen 
else
   read(uQ+iWindow,*) Q_mat(1:(window- (iw_end+window*(iWindow+1)-ic_end+1)) ,i)
   read(uSu+iWindow,*) Su_mat(1:(window- (iw_end+window*(iWindow+1)-ic_end+1)) ,i)
  ! read(uEa+iWindow,*) Ea_mat(1:(window- (iw_end+window*(iWindow+1)-ic_end+1)) ,i)
  ! read(uEi+iWindow,*) Ei_mat(1:(window- (iw_end+window*(iWindow+1)-ic_end+1)) ,i)
  ! read(uSnow+iWindow,*) Snow_mat(1:(window- (iw_end+window*(iWindow+1)-ic_end+1)) ,i)
  ! read(uSs+iWindow,*) Ss_mat(1:(window- (iw_end+window*(iWindow+1)-ic_end+1)) ,i)
  ! read(uSf+iWindow,*) Sf_mat(1:(window- (iw_end+window*(iWindow+1)-ic_end+1)) ,i)

end if
end do


   close(uParam+iWindow, status='delete')
   close(uQ+iWindow, status='delete')
   close(uObj+iWindow, status='delete')
   close(uSu+iWindow, status='delete')
   close(uEa+iWindow, status='delete')
   close(uEi+iWindow, status='delete')
   close(uSnow+iWindow, status='delete')
   close(uSs+iWindow, status='delete')
   close(uSf+iWindow, status='delete')

print *, '----------------------------'
print *, 'Processing window:', iWindow
print *, '----------------------------'

print *, "Max NSE:"
print *, maxval(obj_mat(1,1:count_feasibles(iWindow) ))
print *, "Max LNSE:"
print *, maxval(obj_mat(2,1:count_feasibles(iWindow) ))
print *, "Max VE:"
print *, maxval(obj_mat(3,1:count_feasibles(iWindow) ))
print *, "Max FDC_NSE:"
print *, maxval(obj_mat(4,1:count_feasibles(iWindow) ))



   allocate( temp ( count_feasibles(iWindow)  ))
   allocate( temp1 ( count_feasibles(iWindow) ))
   allocate( pareto_obj(4, count_feasibles(iWindow)  ) )
   allocate( pareto_par(12, count_feasibles(iWindow)  ) )
   allocate( pareto_q(window, count_feasibles(iWindow)  ) )
   allocate( pareto_su(window, count_feasibles(iWindow)  ) )
   !allocate( pareto_ea(window, count_feasibles(iWindow)  ) )
   !allocate( pareto_ei(window, count_feasibles(iWindow)  ) )
   !allocate( pareto_snow(window, count_feasibles(iWindow)  ) )
   !allocate( pareto_ss(window, count_feasibles(iWindow)  ) )
   !allocate( pareto_sf(window, count_feasibles(iWindow)  ) )

print *, ""
print *, "Creating pareto front ..." 

   m=1
   do i=1, count_feasibles(iWindow)
      ! temp(:)= .TRUE.
      ! do j=1,3 !4
      !	   temp1=(1-obj_mat (j,1:count_feasibles(iWindow)) .lt. 1-obj_mat (j,i)) 
      !	   temp = ((temp1 .eqv. .TRUE.) .and. (temp .eqv. .TRUE.))
      ! end do
      !	if (any(temp) .eqv. .FALSE.) then
           pareto_obj(1:4,m)    = obj_mat(1:4,i)
           pareto_par(1:12,m)    = par_mat(1:12,i)
           pareto_q(1:window,m) = Q_mat(1:window,i)
           pareto_su(1:window,m) = Su_mat(1:window,i)
           !pareto_ea(1:window,m) = Ea_mat(1:window,i)
           !pareto_ei(1:window,m) = Ei_mat(1:window,i)
           !pareto_snow(1:window,m) = Snow_mat(1:window,i)
           !pareto_ss(1:window,m) = Ss_mat(1:window,i)
           !pareto_sf(1:window,m) = Sf_mat(1:window,i)
           m=m+1
       ! end if
   end do

  deallocate( temp )
  deallocate( temp1 )

!end do !end windowloop

pareto_length=m-1

print *, ''
print *, "Number of pareto points:"
print *, pareto_length

! find space spanned by pareto front and save results to file

!bound1=maxval(1-pareto_obj(1,1:pareto_length) )
!bound2=maxval(1-pareto_obj(2,1:pareto_length) )
!bound3=maxval(1-pareto_obj(3,1:pareto_length) )
!bound4=maxval(1-pareto_obj(4,1:pareto_length) )

deallocate( Su_mat )
!deallocate( Ea_mat )
!deallocate( Ei_mat )
deallocate( Q_mat )
deallocate( par_mat    )
deallocate( obj_mat    )
!deallocate( Snow_mat    )
!deallocate( Ss_mat    )
!deallocate( Sf_mat    )

write(window_string,'(I0)') iWindow

open(uParam, file=trim(adjustl(output_dir_cal)) // trim(adjustl("Parameters_")) // trim(adjustl(window_string))&
                  // trim(adjustl(".txt")), status='unknown', action='write')
open(uQ, file=trim(adjustl(output_dir_cal)) // trim(adjustl("Q_"))// trim(adjustl(window_string))&
                  // trim(adjustl(".txt")), status='unknown', action='write')
!open(uFinalStates, file=trim(adjustl(output_dir_cal)) // trim(adjustl("FinalStates.txt")), status='unknown', action='write')
open(uObj, file=trim(adjustl(output_dir_cal)) // trim(adjustl("Objectives_")) // trim(adjustl(window_string))  &
             // trim(adjustl(".txt")),  status='unknown', action='write')
open(uSu, file=trim(adjustl(output_dir_cal)) // trim(adjustl("Su_"))// trim(adjustl(window_string))&
                  // trim(adjustl(".txt")), status='unknown', action='write')
!open(uEa, file=trim(adjustl(output_dir_cal)) // trim(adjustl("Ea_"))// trim(adjustl(window_string))&
!                  // trim(adjustl(".txt")), status='unknown', action='write')
!open(uEi, file=trim(adjustl(output_dir_cal)) // trim(adjustl("Ei_"))// trim(adjustl(window_string))&
!                  // trim(adjustl(".txt")), status='unknown', action='write')
!open(uSnow, file=trim(adjustl(output_dir_cal)) // trim(adjustl("Snow_"))// trim(adjustl(window_string))&
!                  // trim(adjustl(".txt")), status='unknown', action='write')
!open(uSs, file=trim(adjustl(output_dir_cal)) // trim(adjustl("Ss_"))// trim(adjustl(window_string))&
!                  // trim(adjustl(".txt")), status='unknown', action='write')

!open(uSf, file=trim(adjustl(output_dir_cal)) // trim(adjustl("Sf_"))// trim(adjustl(window_string))&
!                  // trim(adjustl(".txt")), status='unknown', action='write')


write(uParam,'(12(1X a8))'),  "Meltfactor", "Tthresh", "Imax", "Sumax", "beta", &
                              "Kf", "Ks", "LP", "D", "Pmax", "a", "b"

write(formHeader, *) '(2X a10, 2X a10, 2X a10, 2X a10)'
write(formDataObj, *) '(2X f10.3, 2X f10.3, 2X f10.3, 2X f10.3)'

write(uObj,formHeader), 'NSE','LNSE','VE','LNSE_FDC'

do i=1, pareto_length
   write(uObj,formDataObj),  pareto_obj(1:4,i)
   write(uParam,'(12(1X f8.2))'),  pareto_par(1:12,i)
   write(uQ,'(3650(1X f6.2))'),  pareto_q(:,i)
   write(uSu,'(3650(1X f8.2))'),  pareto_su(:,i)
  ! write(uEa,'(3650(1X f6.2))'),  pareto_ea(:,i)
  ! write(uEi,'(3650(1X f6.2))'),  pareto_ei(:,i)
  ! write(uSnow,'(3650(1X f6.2))'),  pareto_snow(:,i)
  ! write(uSs,'(3650(1X f6.2))'),  pareto_ss(:,i)
  ! write(uSf,'(3650(1X f6.2))'),  pareto_sf(:,i)
end do

!paretospace
!count_solutions=0
!do i=1, count_feasibles(iWindow)
!   if( (1-obj_mat(1,i) .le. bound1) .and. &
!       (1-obj_mat(2,i) .le. bound2) .and. &
!       (1-obj_mat(3,i) .le. bound3) .and. &
!       (1-obj_mat(4,i) .le. bound4)) then
!        count_solutions   = count_solutions+1
!        write(uObj,formDataObj),  obj_mat(1:4,i)
!        write(uParam,'(9(1X f6.2))'),  par_mat(:,i)
!        write(uQ,'(3650(1X f6.2))'),  Q_mat(:,i) !every row is solution, max is 10years window (3650 days)
!   end if
!end do

 close(uParam)
 close(uQ)
 close(uObj)



!print *, ""
!print *, "Number of solutions in pareto space:"
!print *, count_solutions

deallocate(pareto_obj)
deallocate(pareto_par)
deallocate(pareto_q)
!deallocate(pareto_ea)
!deallocate(pareto_ei)
deallocate(pareto_su)
!deallocate(pareto_snow)
!deallocate(pareto_ss)
!deallocate(pareto_sf)
end do







print *, '----------------------------'
print *, ''
print *, "Optimization finished!"

end subroutine



end module mo_window_cal
