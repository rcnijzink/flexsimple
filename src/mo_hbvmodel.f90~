MODULE mo_hbvmodel
! Module that contains all the subroutines and functions that are part of the HBV model. The script is originally written by TUWIEN as a fixed format fortran script that can be used in R. It was modified and placed in a fortran framework to make adjustments and calibration runs possible. 

!Written by: TUWIEN 2009
!References: 
!Adjustments: Free format fortran and clean-up of script. R.C. Nijzink june 2014



IMPLICIT NONE

CONTAINS

      subroutine hbvmodel(param,incon, prec,airt,ep,output)

USE mo_readdata

      	integer 				:: itsteps	! number of timesteps
       	real*8, dimension(16), intent(in)	:: param	! model parameters
      	real*8, dimension(4),intent(in)		:: incon	! initial conditions of states	
	integer					:: maxparam	! maximum number of parameters
	integer 				:: i		! counter
	integer					:: irf		! counter lag function
	integer 				:: it		! counter of timestep
      	real*8,dimension(:), intent(in)		:: prec		! precipation series
	real*8,dimension(:), intent(in)		:: airt		! temperature series
	real*8,dimension(:), intent(in)		:: ep 		! evaporation series
      	real*8,allocatable, dimension(:,:), intent(out)	:: output ! Output
      	real*8 					:: csf		! Snow parameter
	real*8 					:: ddf		! degree day factor
	real*8 					:: tr 		! trheshold temperature rain
	real*8 					:: ts		! threshold temperature snow
 	real*8 					:: meltt 	! melt temperature
	real*8 					:: lprat 	! fraction of soil moisture for evap
	real*8 					:: LP 		! soil moisture for evaporation
	real*8 					:: FC		! field capacity
	real*8 					:: BETA		! beta for run-off function
	real*8 					:: k0		! reservoir coefficient overland flow
	real*8 					:: k1 		! reservoir coefficient upper soil
	real*8 					:: k2 		! reservoir coefficient lower soil
	real*8 					:: lsuz		! threshold for overland flow
	real*8 					:: cperc 	! percolation rate
	real*8 					:: bmax 	! base of lag function at low flows
	real*8 					:: croute	! lag function scaling parameter
      	real*8 					:: cperc_deep	! deep infiltration loss
	real*8 					:: bq		! adjusted base of lag function
      	real*8 					:: temp		! temperature at timestep it
	real*8 					:: precip 	! precipitation at timestep it
	real*8 					:: swe 		! snow water equivalent
	real*8 					:: rain 	! rain at timestep it
	real*8 					:: snow		! snow at timestep it
	real*8 					:: melt		! melt at timestep it
      	real*8 					:: etp 		! evaporation at timestep it
	real*8 					:: dmoist 	! delta moisture
	real*8					:: moist 	! soil moisture content
	real*8					:: dq 		! outflow soil moisture
	real*8 					:: eta		! actual evaporation
      	real*8 					:: suz		! upper zone storage
	real*8					:: slz 		! lower zone storage
	real*8 					:: qg 		! groundwater outflow
	real*8					:: q0 		! overland flow
	real*8					:: q1 		! outflow upper zone
	real*8 					:: q2 		! outflow lower zone
	real*8, allocatable, dimension(:)	:: q		! final discharge
      	real*8, allocatable, dimension(:)	:: dquh		! lag function discharge
      	integer 				:: bql		! integer base lag function


   
!Initialize model parameters

itsteps=size(prec)
allocate( dquh( itsteps) )
allocate( q( itsteps) )
allocate( output(12,itsteps) )


      csf=param(1)      
      ddf=param(2)      
      tr=param(3)
      ts=param(4)
      meltt=param(5) 

      lprat=param(6)
      FC=param(7)      
      BETA=param(8)

      LP=lprat*fc

      k0=param(9)      
      k1=param(10)      
      k2=param(11)
      lsuz=param(12)
                  
      cperc=param(13)
      bmax=param(14)      
      croute=param(15)
      cperc_deep=param(16) 	      
      

!Initialize the states of the model

      moist=incon(1) 		! initial moisture content
      swe=incon(2)   		! initial snow water equivalent
      suz=incon(3)   		! initial upper zone content
      slz=incon(4) 		! initial lower zone content

  
! Prepare forcing

!if(area.gt.0.0) then
        do i=1,itsteps
        q(i)=0.
        dquh(i)=0.
        end do

       do it=1,itsteps
            precip=prec(it)

            temp=airt(it)

            etp=ep(it)
  
      if (temp.lt.-0.1)then
      etp=0.
      endif

       if(precip.lt.-998.00) then
        output(1,it)=-999.99 
        output(2,it)=-999.99
        output(3,it)=-999.99
        output(4,it)=-999.99
        output(5,it)=-999.99
        output(6,it)=-999.99
       endif

!call snow module
if(snow_flag .eqv. .TRUE.) then
        call snowmod(csf,ddf,tr,ts,meltt,temp,precip,swe, rain,snow,melt) 
else 
rain=precip
melt=0
snow=0
end if

!call soilmoisture module
	call soilmoisture(rain,melt,etp,LP,FC,BETA,dmoist,moist,dq,eta) 
	call respfunc(dq,k0,lsuz,k1,k2,cperc,bmax,croute,suz,slz,bql,dquh,qg,q0,q1,q2)

!add dquh (discharge because of lag function) to final discharge series
        do 300,irf=1,bql
         if((it+irf-1).gt.itsteps) goto 301
         q(it+irf-1)=q(it+irf-1)+dquh(irf)
300     continue

301     continue

!determine final values for this timestep, output in same unit as input


!write to output
       output(1,it)=q(it) 
       output(2,it)=swe
       output(3,it)=moist/FC
       output(4,it)=rain
       output(5,it)=snow
       output(6,it)=melt
       output(7,it)=q0
       output(8,it)=q1
       output(9,it)=q2
       output(10,it)=eta
       output(11,it)=suz
       output(12,it)=slz



       enddo

      !endif
      



deallocate( dquh )
deallocate( q )


      end subroutine hbvmodel


!------------------------------------------------------------------------------------------------


      subroutine respfunc(dq,k0,lsuz,k1,k2,cperc,bmax,croute,suz, slz,bql,dquh,qg,q0,q1,q2)

      
      integer 				:: bql
      integer				:: j
      integer				:: rat
      real*8 				:: dq
      real*8 				:: k0 
      real*8 				:: lsuz 
      real*8 				:: k1
      real*8 				:: k2 
      real*8 				:: cperc
      real*8				:: slzin
      real*8 				:: bmax 
      real*8 				:: croute
      real*8 				:: cperc_deep
      real*8				:: bq
      real*8 				:: suz 
      real*8 				:: slz 
      real*8 				:: suzold 
      real*8 				:: slzold
      real*8 				:: q0 
      real*8 				:: q1 
      real*8 				:: q2 
      real*8 				:: qg
      real*8, allocatable, dimension(:)	:: dquh


!     ----- new ---
      rat=1.0
      suzold=suz+rat*dq
      slzold=slz+(1.-rat)*dq
      slzin=cperc

      if(suzold.lt.0.) suzold=0.
      if(slzold.lt.0.) slzold=0.


!     --- upper storage ---
      if(suzold.gt.lsuz) then
       q0=(suzold-lsuz)/k0*exp(-1./k0)
       if(q0.lt.0.) q0=0.
       if(q0.gt.(suzold-lsuz)) q0=suzold-lsuz
      else
       q0=0.
      endif
      suzold=suzold-q0 
      q1=-slzin+(slzin+suzold/k1)*exp(-1./k1) !check this; strange: outflow is minus percolation?
      if(q1.lt.0.0) q1=0.
      suz=suzold-q1-slzin
      if(suz.lt.0.) then
       suz=0.
       slzin=suzold
       endif

!     --- lower storage ---    
       q2=slzin-(slzin-slzold/k2)*exp(-1./k2)
       if(q2.lt.0.) q2=0.
       slz=slzold-q2+slzin-cperc_deep		!cperc_deep added
        if(slz.lt.0.) then
         !slz=0.				!negative values are allowed
         q2=0 !slzold+slzin
        endif
      
      
      qg=q0+q1+q2

!     --- transformation/lag function ---
      if((bmax-croute*qg).gt.1.0) then 
       bq=bmax-croute*qg		!base of lag function
       bql=INT(bq)			!make base integer
       !sum=0.
       do 400, j=1,bql
        if(j.le.bql/2) then
         dquh(j)=((j-0.5)*4.*qg)/(bql*bql*1.)
        elseif(abs(j-(bql/2.+0.5)).lt.0.1) then
         dquh(j)=((j-0.75) *4.*qg)/(bql*bql*1.)
        else
         dquh(j)=((bql-j+0.5)*4.*qg)/(bql*bql*1.)
        endif
         !sum=sum+dquh(j)
400    continue
      else
       bql=1
       dquh(1)=qg
       !sum=qg 
      endif
      return 
      
      end subroutine respfunc

!--------------------------------------------------------------------------------------------------

      subroutine soilmoisture(rain,melt,etp,LP,FC,Beta,dmoist,moist, dq,eta)

      real*8 			:: rain 
      real*8 			:: melt 
      real*8 			:: LP 
      real*8 			:: beta 
      real*8 			:: FC 
      real*8 			:: moistold 
      real*8 			:: moist 
      real*8			:: xx
      real*8 			:: dq 
      real*8 			:: dmoist
      real*8 			:: etp 
      real*8 			:: eta

!     --- soil moisture accounting ----
      moistold=moist

      dq=((moistold/FC)**beta)*(rain+melt)     
      	if(dq.gt.(rain+melt)) then 
	dq=rain+melt
	end if
      	dmoist=rain+melt-dq
	
      	if(dmoist.lt.0.) then 
	dmoist=0.
	end if
      moist=moistold+dmoist
	
      	if(moist.gt.fc) then
        dq=(moist-fc)+dq
        moist=fc
      	end if
!     --- calculate evapotranspiration ---
      if(moist.lt.LP) then
       ETA=moist*ETP/LP 
	       if(eta.gt.etp) then
		       eta=etp    
	       end if
      	else
       ETA=ETP
      	endif
      	if(eta.lt.0.) then 
	eta=0.
	end if
!     --- substract eta of soilmoisture ---
      xx=moist
      moist=moist-eta
      if(moist.lt.0.) then
       eta=xx     
       moist=0.
      end if
	
      return
      
      end subroutine soilmoisture

!------------------------------------------------------------------------------------------------

      subroutine snowmod(csf,ddf,tr,ts,melttemp,temp,precip,swe, rain,snow,melt)

       real*8 				:: ddf
       real*8 				:: csf 
       real*8 				:: tr 
       real*8 				:: ts 
       real*8 				:: melttemp 
       real*8 				:: dsrtemp 
       real*8 				:: dd1
       real*8 				:: temp 
       real*8 				:: precip 
       real*8 				:: rain 
       real*8 				:: snow 
       real*8 				:: sweold 
       real*8 				:: swe 		!snow water equivalent
       real*8 				:: melt     

print *, "Snowmodule is on" 


      if(temp.lt.ts) then
       snow=precip
      elseif(temp.gt.tr) then
       snow=0.
      else
       snow=precip*abs(temp-tr)/abs(tr-ts)
      endif
      rain=precip-snow


       melt=(temp-melttemp)*ddf 
       if (melt .lt. 0.) melt=0.
!      --- Determine SWE
       sweold=swe
       swe=sweold+csf*snow-melt
       if (swe.lt.0.0001) then
          swe=0.
          melt=sweold+csf*snow
          if(melt.lt.0.) melt=0.
       end if   
       return
      end subroutine snowmod

END MODULE mo_hbvmodel
