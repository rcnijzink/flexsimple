MODULE mo_multi_obj

! Module for optimization of the HBV model by Monte Carlo simulation. It will produce several files in the folders "Cal" and "Val":
! Pareto_Q.txt  		: simulated river discharge for all pareto optimal solutions
! Swe.txt			: snow water equivalent for all pareto optimal solutions
! rmoist.txt			: relative moisture content for all pareto optimal solutions.
! rain.txt			: rain for all pareto optimal solutions  
! snow.txt			: snow  for all pareto optimal solutions
! melt.txt			: melt water equivalent for all pareto optimal solutions
! q0.txt			: surface runoff for all pareto optimal solutions
! q1.txt			: fast runoff for all pareto optimal solutions
! q2.txt			: slow runoff for all pareto optimal solutions
! eta.txt			: evaporation for all pareto optimal solutions
! suz.txt			: upper zone storage for all pareto optimal solutions
! slz.txt			: lower zone storage for all pareto optimal solutions
! rslz.txt			: relative lower zone storage for all pareto optimal solutions
! Objectives.txt		: objective function values for all pareto optimal solutions
! Pareto_parameters.txt		: parameters for all pareto optimal solutions
! Feasible_objectives.txt	: objective function values all feasible solutions (0>)

!Written by: R.C. Nijzink June 2014
!References: 
!Adjustments: 



IMPLICIT NONE

CONTAINS

	subroutine dynia(par_max,par_min,incon, prec_data,temp_data,etp_data,&
                             dem, cellsize,Qobs_data, dates_data)
		
USE mo_model
USE mo_readdata
USE mo_objectives
USE mo_eval_signatures
USE mo_init_random_seed

	real*8,dimension(4), intent(in)		        :: incon	! initial conditions states
	real*8,dimension(4)	        		:: incon_val	! initial conditions states
	real*8,dimension(:), allocatable, intent(in)	:: etp_data	! evaporation data
	real*8,dimension(:), allocatable, intent(in)	:: prec_data 	! precipitation data
	real*8,dimension(:), allocatable, intent(in)	:: temp_data 	! temperature data
        real*8, dimension(:,:), allocatable, intent(in)     :: dem
        real*8,intent(in)                       :: cellsize
	real*8,dimension(:), allocatable, intent(in)	:: Qobs_data	! observed discharge
	character*10,dimension(:), allocatable, intent(in)	:: dates_data	! observed discharge
        real*8,dimension(11) 				:: r		! random number array
	real*8,dimension(11), intent(in)		:: par_max	! maximum parameter values
	real*8,dimension(11), intent(in)		:: par_min	! minimum parameter values
	real*8,dimension(11)             		:: paramset	! set of parameters
	real*8,allocatable, dimension(:)		:: q		! modelled discharge
	real*8,allocatable, dimension(:)		:: qval		! validation discharge
	real*8, dimension(:,:), allocatable 	        :: EC    	! evalutation criteria
	real*8, dimension(:,:), allocatable 	        :: ECval    	! evalutation criteria
	real*8						:: NSE		! Nash-Sutcliffe efficienct
	real*8						:: LNSE		! log NSE
	real*8						:: VE		! Volume error
	real*8						:: FDC_NSE	! Nash of flow duration curve
	real*8						:: NSE_val	! NSE for validation	
	real*8						:: LNSE_val	! log NSE for validation
	real*8						:: VE_val	! Volume error validation
	real*8						:: FDC_NSE_val	! validation Nash FDC
	integer						:: length	! length of period
	integer						:: val_length	! length of validation period
	real*8, allocatable, dimension(:,:)	        :: output	! output matrix
	real*8, allocatable, dimension(:,:)	        :: output_val	! output matrix validation
	integer						:: nn 		! counter
	integer, allocatable, dimension(:)		:: seed		! initial random seed
	integer						:: t		! counter
	integer						:: count_feasibles !number of feasible sets
	integer						:: count_solutions !number of final solutions
	integer						:: j		! counter
	integer						:: i		! counter
	integer						:: k		! counter
	integer						:: m		! counter
	integer						:: jj		! counter
	integer						:: ii		! counter
	real*8						:: bound1	! pareto_bound
	real*8						:: bound2	! pareto_bound
	real*8						:: bound3	! pareto_bound
	real*8						:: bound4	! pareto_bound
	real*8, dimension(:,:), allocatable		:: par_mat	! matrix with parameters
	real*8, dimension(:,:), allocatable		:: q_mat	! matrix with modelled Q
	real*8, dimension(:,:), allocatable		:: qval_mat	! matrix with validated Q
	real*8, dimension(:,:,:), allocatable		:: output_mat	! output matrix
	real*8, dimension(:,:), allocatable		:: outputval_mat! output validation		
	real*8, dimension(:,:), allocatable		:: obj_mat	! matrix with objective functions
	real*8, dimension(:,:), allocatable		:: objval_mat	! matrix with validation objective functions
	real*8, dimension(:,:), allocatable		:: pareto_obj	! matrix with pareto objective function values
!	real*8, dimension(:,:), allocatable		:: pareto_par	! matrix with pareto parameters
!	real*8, dimension(:,:,:), allocatable		:: pareto_output! matrix with pareto output
        integer                                         :: fileunit	
	real*8, dimension(:,:), allocatable		:: final_obj	! matrix with final objective function values
	real*8, dimension(:,:), allocatable		:: final_par	! matrix with final parameters
	real*8, dimension(:,:,:), allocatable		:: final_out    ! matrix with final
	real*8, dimension(:,:), allocatable		:: final_states ! matrix with final states
	logical, dimension(:), allocatable		:: temp, temp1	! temperoray arrays
	character(256)                        		:: formData	! format of data
	character(256)                        		:: formDataObj	! format of data objectives
	character(256)                        		:: formDataPar	! format of data parameters
	character(256)                        		:: formHeader	! format of data headers
	character(256)                        		:: formHeaderPar! format of headers
	integer						:: pareto_length! number of pareto solutions
	integer						:: uObj		! file unit all objectives
	integer						:: uObjPar	! file unit pareto objectives
	integer						:: uObjval 	! file unit objectives validation
	integer						:: uParam	! file unit parameters
	integer						:: uParamPar	! file unit pareto parameters
	integer						:: uSig 	! file unit objectives validation
	integer						:: uSigVal 	! file unit objectives validation
	integer						:: uQ 		! file unit Q
	integer						:: uQPar	! file unit Q
	integer						:: uQval	! file unit Q validation
        real*8                                          :: fIt




uQ=10
uQval=12
uQPar=13
uParam=14
uParamPar=15
uObj=16
uObjval=17
uObjPar=18
uSig=19
uSigVal=20


length=size(prec_data( iw_start:iv_end ))

allocate( q( length) )
allocate( output_mat( 5, length, int(0.5*Iterations)) )
allocate( par_mat(11, int(0.5*Iterations)) )
allocate( obj_mat(4, int(0.5*Iterations)) )

call init_random_seed()





!start monte carlo runs

count_feasibles = 0
fIt = 0.1

 do nn=1, Iterations

	call random_number(r)

	paramset=r*(par_max-par_min)+par_min	! random parameter set

	call model(paramset,incon, prec_data( iw_start:iv_end ) &
	,temp_data(iw_start:iv_end),etp_data(iw_start:iv_end), dem, cellsize, output)

	q=output(1,:)
!print *, q

	!determine objectives
	 call NashEfficiency(Qobs_data(iw_end+1:ic_end),q(iw_end+1:ic_end), NSE)
	 call LogNashEfficiency(Qobs_data(iw_end+1:ic_end),q(iw_end+1:ic_end), LNSE)
	 call VolumeError(Qobs_data(iw_end+1:ic_end),q(iw_end+1:ic_end), VE)
	 call FDCNashEfficiency(Qobs_data(iw_end+1:ic_end),q(iw_end+1:ic_end), FDC_NSE)

	!keep parameter set when all objectives are bigger than 0, with maximum size of 5000

	if( (NSE .gt. zero_dp) .and. (LNSE .gt. zero_dp) .and. (VE .gt. zero_dp) .and. (FDC_NSE .gt. zero_dp) ) then
	count_feasibles = count_feasibles + 1

	par_mat(:,count_feasibles)     = paramset		!every column is one run
	output_mat(1,:, count_feasibles) = output(1,:)
	output_mat(2:5,:, count_feasibles) = output(10:13,:)
	obj_mat(:,count_feasibles)= (/NSE, LNSE, VE, FDC_NSE/)
        


	end if


if(nn .eq. int(fIt*Iterations)) then
print *, "Iterations finished: ", nn
print *, "Feasible solutions : ", count_feasibles 
print *, ""
fIt = fIt + 0.1
end if



end do



print *, "Max NSE:"
print *, maxval(obj_mat(1,1:count_feasibles))
print *, "Max LNSE:"
print *, maxval(obj_mat(2,1:count_feasibles))
print *, "Max VE:"
print *, maxval(obj_mat(3,1:count_feasibles))
print *, "Max FDC_NSE:"
print *, maxval(obj_mat(4,1:count_feasibles))


print *, "Feasible parameter sets:"
print *, count_feasibles
print *, "Creating pareto front..."


!now create pareto front
allocate( temp ( count_feasibles))
allocate( temp1 ( count_feasibles))
!allocate( pareto_output( 5, length, count_feasibles) )
allocate( pareto_obj(4, count_feasibles) )
!allocate( pareto_par(10, count_feasibles) )
allocate( final_out(5, length, count_feasibles) )
allocate( final_obj(4, count_feasibles) )
allocate( final_par(11, count_feasibles) )

m=1
do i=1, count_feasibles
    temp(:)= .TRUE.
    do j=1,4
	temp1=(1-obj_mat (j,1:count_feasibles) .lt. 1-obj_mat (j,i)) 
	temp = ((temp1 .eqv. .TRUE.) .and. (temp .eqv. .TRUE.))
    end do
	if (any(temp) .eqv. .FALSE.) then
     	pareto_obj(1:4,m)    = obj_mat(1:4,i)
!        pareto_output(:,:,m) = output_mat(:,:,i)
!	pareto_par(:,m) = par_mat(:,i)
        m=m+1
    end if
end do

pareto_length=m-1

print *, "Number of pareto points:"
print *, pareto_length

! find space spanned by pareto front

bound1=maxval(1-pareto_obj(1,1:pareto_length) )
bound2=maxval(1-pareto_obj(2,1:pareto_length) )
bound3=maxval(1-pareto_obj(3,1:pareto_length) )
bound4=maxval(1-pareto_obj(4,1:pareto_length) )

deallocate(pareto_obj)

count_solutions=0
do i=1, count_feasibles
if( (1-obj_mat(1,i) .le. bound1) .and. &
    (1-obj_mat(2,i) .le. bound2) .and. &
    (1-obj_mat(3,i) .le. bound3) .and. &
    (1-obj_mat(4,i) .le. bound4)) then
     count_solutions   = count_solutions+1
     final_obj(1:4,count_solutions)  = obj_mat(1:4,i)
     final_par(:,count_solutions)    = par_mat(:,i)
     final_out(:,:,count_solutions)    = output_mat(:,:,i)
     
end if
end do

print *, ""
print *, "Number of solutions in pareto space:"
print *, count_solutions


deallocate( output_mat )
deallocate( par_mat    )
deallocate( obj_mat    )
deallocate( temp       )
deallocate( temp1      )
deallocate( q          )



print *, ""
print *, "Determine signatures ..."
print *, ""

allocate( EC(count_solutions, 26) )

do i=1, count_solutions

call eval_signatures(final_out(1,iw_end+1:ic_end,i), Qobs_data(iw_end+1:ic_end), dates_data(iw_end+1:ic_end), &
                     .FALSE., EC(i,:) )
end do


!validate

val_length=size(prec_data( iv_start:iv_end ))
allocate( outputval_mat (val_length, count_solutions) )
allocate( qval( val_length) )
allocate( objval_mat( 4, count_solutions) )


print *, "Start validation" 


do ii=1, count_solutions

incon_val=final_out(2:5,ic_end,ii) 

call model(final_par(:,ii),incon_val, prec_data( iv_start:iv_end ) &
	,temp_data(iv_start:iv_end),etp_data(iv_start:iv_end), dem, cellsize, output_val)

	qval=output_val(1,:)

	 call NashEfficiency(Qobs_data(iv_start:iv_end),qval, NSE_val)
	 call LogNashEfficiency(Qobs_data(iv_start:iv_end),qval, LNSE_val)
	 call VolumeError(Qobs_data(iv_start:iv_end),qval, VE_val)
	 call FDCNashEfficiency(Qobs_data(iv_start:iv_end),qval, FDC_NSE_val)

	objval_mat(:,ii)= (/NSE_val, LNSE_val, VE_val, FDC_NSE_val/)
	outputval_mat(:,ii)=qval

end do





print *, "Determine signatures validation..."
allocate( ECval(count_solutions, 26) )

do i=1, count_solutions

call eval_signatures(outputval_mat(:,i), Qobs_data(iv_start:iv_end), dates_data(iv_start:iv_end), &
                     .FALSE., ECval(i,:) )

end do



print *, "Saving results..."


! write output calibration and validation


  open(uQ, file=trim(adjustl(output_dir_cal)) // trim(adjustl("Q.txt")), status='unknown', action='write')
	do jj=iw_end+1,ic_end 
  	write(uQ,'(100000(1X f6.2))'),  final_out(1,jj,1:count_solutions)
	end do
 close(uQ)


open(uQval, file=trim(adjustl(output_dir_val)) // trim(adjustl("Q.txt")), status='unknown', action='write')
	do jj=1,val_length 
  	write(uQval,'(100000(1X f6.2))'),  outputval_mat(jj,1:count_solutions)
	end do
 close(uQval)


write(formHeader, *) '(2X a10, 2X a10, 2X a10, 2X a10)'
write(formDataObj, *) '(2X f10.3, 2X f10.3, 2X f10.3, 2X f10.3)'
open(uObj, file=trim(adjustl(output_dir_cal)) // trim(adjustl("Objectives.txt")), status='unknown', action='write')
write(uObj,formHeader), 'NSE','LNSE','VE','LNSE_FDC'
	do jj=1,count_solutions 
  	write(uObj,formDataObj),  final_obj(1:4,jj)
	end do
 close(uObj)


write(formHeader, *) '(2X a10, 2X a10, 2X a10, 2X a10)'
write(formDataObj, *) '(2X f10.3, 2X f10.3, 2X f10.3, 2X f10.3)'
open(uObjval, file=trim(adjustl(output_dir_val)) // trim(adjustl("Objectives.txt")), status='unknown', action='write')
write(uObjval,formHeader), 'NSE','LNSE','VE','LNSE_FDC'
	do jj=1,count_solutions
  	write(uObjval,formDataObj),  objval_mat(1:4,jj)
	end do
 close(uObjval)


! Parameters determined in calibration and used in validation

open(uParam, file=trim(adjustl(output_dir_cal)) // trim(adjustl("Parameters.txt")), status='unknown', action='write')
write(uParam,'(10(1X a8))'),  "Meltfactor", "Tthresh", "Imax", "Sumax", "beta", &
                              "Nlagf", "Kf", "Ks", "LP", "D", "Sumin"
	do jj=1,count_solutions
  	write(uParam,'(11(1X f6.2))'),  final_par(:, jj)
	end do
 close(uParam)



! Performances for signatures
  open(uSig, file=trim(adjustl(output_dir_cal)) // trim(adjustl("Signatures.txt")), status='unknown', action='write')
write(uSig,'(26(A10))'), 'Q_MA', 'AC', 'AC_low', 'AC_high', 'RLD', 'DLD', 'Q5', 'Q50', 'Q95', 'Q5_low', 'Q50_low', 'Q95_low', &
                        'Q5_high', 'Q50_high', 'Q95_high', 'Peaks', 'Peaks_low', 'Peaks_high', 'Qpeak10','Qpeak50', &
                        'Qlow_peak10', 'Qlow_peak50','Qhigh_peak10', 'Qhigh_peak50', 'FDC_serie', 'AC_serie'
	do jj=1, count_solutions
  	write(uSig,'(26(1X f6.2))'),  EC(jj,:)
	end do
 close(uSig)

  open(uSigVal, file=trim(adjustl(output_dir_val)) // trim(adjustl("Signatures.txt")), status='unknown', action='write')
write(uSigVal,'(26(A10))'), 'Q_MA', 'AC', 'AC_low', 'AC_high', 'RLD', 'DLD', 'Q5', 'Q50', 'Q95', 'Q5_low', 'Q50_low', 'Q95_low',&
                           'Q5_high','Q50_high', 'Q95_high', 'Peaks', 'Peaks_low', 'Peaks_high', 'Qpeak10','Qpeak50', & 
                           'Qlow_peak10', 'Qlow_peak50', 'Qhigh_peak10', 'Qhigh_peak50', 'FDC_serie', 'AC_serie'
	do jj=1, count_solutions 
  	write(uSigVal,'(26(1X f6.2))'),  ECval(jj,:)
	end do
 close(uSigval)




print *, "Optimization finished!"

end subroutine



end module mo_multi_obj
