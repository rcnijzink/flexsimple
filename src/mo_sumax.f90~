!> \file mo_mpr_smhorizons.f90

!> \brief setting up the soil moisture horizons

!> \details This module sets up the soil moisture horizons

!> \author Stephan Thober, Rohini Kumar
!> \date Dec 2012

module mo_sumax


  implicit none

  public :: gen_sumax

  private

contains

 ! ----------------------------------------------------------------------------

  !      NAME
  !         mpr_sumax

  !>        \brief upscale soil moisture horizons

  !>        \details calculate soil properties at the level 1.\n
  !>        Global parameters needed (see mhm_parameter.nml):\n
  !>           - param(1) = rootFractionCoefficient_forest     \n
  !>           - param(2) = rootFractionCoefficient_impervious \n
  !>           - param(3) = rootFractionCoefficient_pervious   \n
  !>           - param(4) = infiltrationShapeFactor            \n


  !      INTENT(IN)
  !>        \param[in] "real*8    :: param(4)"         - four global parameters
  !>        \param[in] "real*8    :: nodata"           - no data value
  !>        \param[in] "integer :: nHorizons_mHM"    - number of horizons to model
  !>        \param[in] "integer :: HorizonDepth(:)"  - [mm] horizon depth from surface,
  !>                                                     postive downwards
  !>        \param[in] "integer :: L0_LUC(:,:)"      - land use cover at level 0
  !>        \param[in] "integer :: L0_soilID(:,:)"   - soil IDs at level 0
  !>        \param[in] "integer :: nHorizons(:)"     - horizons per soil type
  !>        \param[in] "integer :: nTillHorizons(:)" - Number of Tillage horizons
  !>        \param[in] "real*8    :: thetaS_till(:,:,:)"  - saturated water content of soil
  !>                                                     horizons upto tillage depth,
  !>                                                     f(OM, management)
  !>        \param[in] "real*8    :: thetaFC_till(:,:,:)" - Field capacity of tillage 
  !>                                                     layers; LUC dependent, f(OM, management)
  !>        \param[in] "real*8    :: thetaPW_till(:,:,:)" - Permament wilting point of
  !>                                                     tillage layers; LUC dependent, f(OM, management)
  !>        \param[in] "real*8    :: thetaS(:,:)"         - saturated water content of soil
  !>                                                     horizons after tillage depth
  !>        \param[in] "real*8    :: thetaFC(:,:)"     - Field capacity of deeper layers
  !>        \param[in] "real*8    :: thetaPW(:,:)"     - Permanent wilting point of deeper layers
  !>        \param[in] "real*8    :: Wd(:,:,:)"        - weights of mHM Horizons according to horizons provided
  !>                                                     in soil database
  !>        \param[in] "real*8    :: Db(:,:,:)"        - Bulk density
  !>        \param[in] "real*8    :: DbM(:,:)"         - mineral Bulk density
  !>        \param[in] "real*8    :: RZdepth(:)"       - [mm] Total soil depth
  !>        \param[in] "integer :: L0_cellCoor(:,:)" - cell coordinates at level 0
  !>        \param[in] "integer :: L0_cell_id(:,:)"  - cell ids of high resolution field, 
  !>                                                     Number of rows times Number of columns
  !>                                                     of high resolution field
  !>        \param[in] "integer :: upp_row_L1(:)"    - Upper row id in high resolution field
  !>                                                     (L0) of low resolution cell (L1 cell)
  !>        \param[in] "integer :: low_row_L1(:)"    - Lower row id in high resolution field
  !>                                                     (L0) of low resolution cell (L1 cell)
  !>        \param[in] "integer :: lef_col_L1(:)"    - Left column id in high resolution 
  !>                                                     field (L0) of low resolution cell
  !>        \param[in] "integer :: rig_col_L1(:)"    - Right column id in high resolution
  !>                                                     field (L0) of low resolution cell
  !>        \param[in] "integer :: nL0_in_L1(:)"     - Number of high resolution cells (L0)
  !>                                                     in low resolution cell (L1 cell)

  !      INTENT(OUT)
  !>       \param[in,out] "real*8 :: L1_beta(:,:)"     - Parameter that determines the
  !>                                                     relative contribution to SM, upscaled
  !>                                                     Bulk density. Number of cells at L1
  !>                                                     times number of horizons in mHM
  !>       \param[in,out] "real*8 :: L1_SMs(:,:)"      - [10^-3 m] depth of saturated SM cont
  !>                                                     Number of cells at L1 times number
  !>                                                     of horizons in mHM
  !>       \param[in,out] "real*8 :: L1_FC(:,:)"       - [10^-3 m] field capacity. Number
  !>                                                     of cells at L1 times number of horizons
  !>                                                     in mHM
  !>       \param[in,out] "real*8 :: L1_PW(:,:)"       - [10^-3 m] permanent wilting point.
  !>                                                     Number of cells at L1 times number 
  !>                                                     of horizons in mHM
  !>       \param[in,out] "real*8 :: L1_fRoots(:,:)"   - fraction of roots in soil horizons.
  !>                                                     Number of cells at L1 times number
  !>                                                     of horizons in mHM

  !      HISTORY
  !>       \author Luis Samaniego, Rohini Kumar, Stephan Thober
  !>       \date Dec 2012
  !        Written Stephan Thober, Dec 2012
  !        Modified, Stephan Thober, Jan 2013 - updated calling sequence for upscaling operators
  !                  Juliane Mai,    Oct 2013 - OLD parametrization
  !                                                --> param(1) = rootFractionCoefficient_forest
  !                                                --> param(2) = rootFractionCoefficient_impervious 
  !                                                --> param(3) = rootFractionCoefficient_pervious
  !                                                --> param(4) = infiltrationShapeFactor
  !                                             -------------------------------
  !                                             rootFractionCoeff_perv   = rootFractionCoeff_forest - delta_1
  !                                             -------------------------------
  !                                             NEW parametrization
  !                                                --> param(1) = rootFractionCoefficient_forest
  !                                                --> param(2) = rootFractionCoefficient_impervious 
  !                                                --> param(3) = delta_1 
  !                                                --> param(4) = infiltrationShapeFactor
  !                  Stephan Thober, Mar 2014 - added omp parallelization

  subroutine gen_sumax( pet, pre, Qobs   )      ! maximum soil moisture capacity 

   use mo_readdata   

    implicit none

    ! Input

    real*8                                  :: canop_int
    real*8                                  :: alpha
    real*8, dimension(:), allocatable       :: cumsum_prec
    real*8, dimension(:), allocatable       :: cumsum_prec_mean
    real*8                                  :: cellsize
    character(10)                             :: cellnum1
    character(10)                             :: cellnum2
    real*8                                  :: DI
    real*8, dimension(:,:), allocatable     :: data_dp_2d
    integer                               :: day, month, year, hour
    real*8                                  :: Ea            !long term mean evaporation
    real*8                                  :: Ea_dist            !long term mean evaporation
    real*8, dimension(:), allocatable       :: Ea_serie
    real*8, dimension(:,:), allocatable     :: Ea_dist_serie
!    real*8, dimension(:,:), allocatable     :: Ed
    real*8, dimension(:), allocatable     :: Ed_serie
    integer                               :: err
    character(200)                            :: fName
    character(100)                            :: formData
    integer                               :: I
    integer                                   :: iBasin
    integer                               :: j
    integer                               :: k
    real*8                                  :: LAI            ! LAI at level-0
    logical, dimension(:,:), allocatable      :: mask0, mask1
    logical, dimension(:,:), allocatable      :: mask_2d
    logical, dimension(:,:), allocatable      :: mask_global
    integer                               :: m
    integer                               :: mm
    real*8,dimension(:), allocatable        :: maximum
    integer,dimension(:), allocatable     :: max_ind
    real*8,dimension(:), allocatable        :: minimum
    integer,dimension(:), allocatable     :: min_ind
    integer                               :: nCells 
    integer                               :: nCells0
    real*8                                  :: newTime 
    real*8, dimension(:,:), allocatable     :: NDVI
    integer                               :: nrows, ncols
    integer                               :: nrows0, ncols0
    integer                               :: nTimeSteps
    integer                               :: n
    integer                               :: max_it 
    real*8, dimension(:), allocatable       :: Peff
    real*8                                  :: pet
    real*8                                  :: pre
    integer                               :: r
    integer                               :: interval
    real*8, dimension(:), allocatable       :: intercept
    real*8, dimension(:), allocatable       :: intercept_1
    real*8, dimension(:), allocatable       :: intercept_2
    integer                               :: iu, id, jl, jr
    integer                               :: ind
    real*8                                  :: RC
    integer                               :: s1, e1
    integer                               :: s0, e0
    real*8,dimension(:), allocatable       :: sumax
    real*8,dimension(:), allocatable        :: sumax_temp
    integer                               :: tt            !timesteps
    real*8, dimension(:,:), allocatable     :: tangent_max
    real*8, dimension(:,:), allocatable     :: tangent_min

    real*8, dimension(:)                    :: Qobs
    integer                               :: x
    integer                               :: u1, u2, u3

    integer                               :: ll

    integer                               :: t_dry


print *, 'Determining SUMAX ...'

    !----------------------------------------------------------
    ! estimate total modeling timesteps including warming days
    !----------------------------------------------------------
    nTimeSteps = iv_end - iw_start



!  read NDVI values
!   fName = trim(adjustl(dirCommonFiles)) // trim('NDVI.asc')
      



 allocate(cumsum_prec( nTimeSteps ))
! allocate(cumsum_prec_mean( nTimeSteps ))
 allocate(Peff( nTimeSteps ))
! allocate(Ea_serie( nTimeSteps ))
! allocate(Q( nTimeSteps ))
 allocate(intercept( nTimeSteps ))
! allocate(pet (nCells, nTimeSteps ) )
! allocate(pet ( nTimeSteps ) )
! allocate(pre (nCells, nTimeSteps ) )
! allocate(pre ( nTimeSteps ) )
! allocate(DI (nCells ) )
! allocate(RC (nCells ) )
! allocate(Ea_dist (nCells ) )
! allocate(Ea_dist_serie (nCells, nTimeSteps ) )
! allocate(Ed (nrows0, ncols0 ) )
 allocate(Ed_serie (nTimeSteps ) )
! allocate(sumax_2_temp (nCells, nTimeSteps) )
! allocate(sumax_2 (nCells) )
! allocate(sumax_3 (nrows0, ncols0 ) )


! initialize
 cumsum_prec = 0_8
 canop_int= 0_8

! time loop for cumulative sums
do tt = 1, nTimeSteps

    
     if( tt .eq. 1) then
      cumsum_prec(tt) =  pre(tt)
     else
      cumsum_prec(tt) = cumsum_prec(tt-1) + pre(tt)
     end if

 
      Peff(tt) = cumsum_prec(tt) - canop_int

end do
!end time loop
  

Ea = ( sum(Peff) - sum(Qobs) ) / real(nTimeSteps, 8) !long term mean actual evaporation


Ea_serie = Ea * (/(I, I=1, nTimeSteps)/) 


Ed_serie(:) = NDVI(n,m) * Ea_serie  
intercept = Peff - Ed_serie

interval = int(365/2 , 4)

allocate(maximum(nTimeSteps))
allocate(max_ind(nTimeSteps))
allocate(minimum(nTimeSteps))
allocate(min_ind(nTimeSteps))
allocate(intercept_1(interval))
allocate(intercept_2(interval))
 

x=0_4 ! number of peaks and minimums
n=0_4

print *, x, n

! find tangents for maximum values
do i = interval+1, (nTimeSteps-interval)
    mm = 0_4
    do j = 1, interval/2
        intercept_1(j)=Peff(i-j)-Ed_serie(i-j)
        intercept_2(j)=Peff(i+j)-Ed_serie(i+j)

        if( (intercept(i) .lt. intercept_1(j)) .or. (intercept(i) .lt. intercept_2(j))) then ! the maximum
            mm=mm+1_4
        end if

    end do

    if( mm .eq. 0_4) then
        x=x+1_4           ! the peak
        max_ind(x) = i     ! make a record with indexes
        maximum(x) = intercept(i)
    end if
end do

deallocate(intercept_1)
deallocate(intercept_2)


! now find accompanying minimum tangents
do i =1, x
    
if(i .ne. x) then
        minimum(i) = minval(intercept(max_ind(i):max_ind(i+1) ) )
        min_ind(i) = minloc(intercept(max_ind(i):max_ind(i+1) ),1 )+ max_ind(i)      ! make a record with indexes
else
        minimum(i) = minval(intercept(max_ind(i):size(intercept,1) ) )
        min_ind(i) = minloc(intercept(max_ind(i):size(intercept,1) ),1 )+ max_ind(i)      ! make a record with indexes
end if

end do


allocate(sumax_temp( x ))
allocate(sumax( x ))
allocate(tangent_max(nTimeSteps, x))
allocate(tangent_min(nTimeSteps, x ))


sumax_temp(1:x) = maximum(1:x) - minimum(1:x)

do i = 1, x

tangent_max(:,i) = maximum(i) + Ed_serie(:)
tangent_min(:,i) = minimum(i) + Ed_serie(:)
end do

sumax = sumax_temp(1:x) !the Sumax



deallocate(maximum)
deallocate(max_ind)
deallocate(minimum)
deallocate(min_ind)
deallocate(sumax_temp)
deallocate(tangent_max)
deallocate(tangent_min)


 

!--------------------------------------
!write output

print *, 'write output SUMAX..'

!write test file
fName=  trim(adjustl(output_dir))//trim(adjustl('sumax.txt'))
 open(95, file=fName, status='unknown', action='write', iostat=err)
! write(formData, *) '(40(f12.3)    )'

do n = 1 , x
    write(95,*) sumax(n) 
end do
 close(95)



  end subroutine gen_sumax

end module mo_sumax
